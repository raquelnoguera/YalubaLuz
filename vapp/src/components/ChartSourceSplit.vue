<template>
    <div class="q-pa-md">
        <canvas id="generation-chart" :style="{width: canvasSize[0], height: canvasSize[1]}"></canvas>
    </div>
    <div class="q-pa-md q-gutter-sm">
        <q-dialog v-model="cardModel">
            <GenerationCardComponent 
                :date="cardDate"
                :labels="cardLabels"
                :colors="cardColors"
                :dataset="cardDataset" />
        </q-dialog>
    </div>
</template>

<script>
/**
 * Displays chart showing the power generated by all renewable and non-renwable energy sources 
 * in 30 days based on selected date.
 * If the selected date is today, then it will look for 30 days in the past. If the date is in the 
 * past, then it will look for 30 days from that date (if the date is 30 days or more ago) or 30
 * days from today (if the date is not 30+ days ago now).
 */
import { Chart, registerables } from 'chart.js';
import { defineComponent } from 'vue';
import { ref, shallowRef, triggerRef, watch, onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useYalubaStore } from '../stores/yaluba.js';
import { useQuasar } from 'quasar';
import { utils } from '../libsjs/utils.js';
import GenerationCardComponent from './GenerationCard.vue';

const filename = "ChartSourceSplit";

export default defineComponent({
    name: 'SplitgenChartComponent',
    components: {
        GenerationCardComponent
    },

    setup () {
        const $q = useQuasar();
        const store = useYalubaStore();
        const { fecha, rango, hora } = storeToRefs(store);
        const chart = shallowRef(null);
        const canvasSize = ref([980, 500]) // used to set the size of the canvas
        const cardDate = ref(null);
        const cardLabels = shallowRef([]);
        const cardColors = shallowRef([]);
        const cardDataset = shallowRef([]);
        const cardModel = ref(false);

        // WATCHERs
        watch(fecha, () => {
            console.debug(`ChartSourceSplit -> fecha: ${fecha.value}`);
            updateList(fecha.value);
        });

        // METHODS

        /**
         * Set the initial date and end date in a way fits 20 days with the constraint that the 
         * latest enddate is today.
         *
         * @param {*} _fechaInicio 
         */
        function resolveDates(_fechaInicio) {
            let currendate = new Date();
            let currentday = new Date(currendate.getFullYear(), currendate.getMonth(), currendate.getDate()).getTime(); // We need the date at midnought
            let [dia, mes, anyo] = _fechaInicio.split("-");
            let inicio = new Date(parseInt(anyo), parseInt(mes) - 1, parseInt(dia)).getTime();  // epoch in seconds
            let period = 30 * 24 * 3600000; // 30 days in milliseconds
            let delta = currentday - inicio;
            let targetinitdate = (delta >= period) ? inicio : (inicio - period + delta);
            // console.debug(`ChartGeneration -> resolveDates() -> inicio: ${inicio}`)
            // console.debug(`ChartGeneration -> resolveDates() -> delta: ${delta}`)
            // console.debug(`ChartGeneration -> resolveDates() -> targetinitdate: ${targetinitdate}`)

            let initdate = new Date(targetinitdate);
            let enddate = new Date(targetinitdate + period);
            let initdatestr = `${initdate.getDate()}-${initdate.getMonth() + 1}-${initdate.getFullYear()}`;
            let enddatestr = `${enddate.getDate()}-${enddate.getMonth() + 1}-${enddate.getFullYear()}`;
            return [initdatestr, enddatestr];
        }

        /**
         * Formats the data to be charted.
         * 
         * @param {array} labels  list of electricity sources
         * @param {array} colors  color associated to each source
         * @param {array} datasets  dataset for each source
         */
        function updateChartData(labels, colors, datasets) {
            console.log("Updating chart data");
            let xlabels = []; // labels for the x axis
            
            // Get the xLabels
            datasets[0].forEach((datavalue) => {
                xlabels.push(datavalue[0]);
            });
            console.debug(`ChartSourceSplit -> updateChartData() -> xlabels: ${xlabels}`)
            let chartData = {
                type: "line",
                data: {
                    labels: xlabels,
                    datasets: [
                    ]
                },
                options: {
                    responsive: true,
                    hover : {
                        mode: 'nearest',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: `Generaci칩n de renovables vs no-renovables`
                        }
                    },
                    lineTension: 0.25,
                    scales: {
                        yAxes: {
                            ticks: {
                                beginAtZero: true,
                                padding: 25
                            },
                            title: {
                                display: true,
                                text: 'MWh'
                            }
                        }
                    },
                    onClick: (event) => {
                        let activePoint = chart.value.getElementsAtEventForMode(event, 'nearest', { intersect: false }, true);
                        // make sure click was on an actual point
                        if (activePoint.length > 0) {
                            var clickedDatasetIndex = activePoint[0].datasetIndex;
                            var clickedElementindex = activePoint[0].index;
                            // var label = chart.value.data.labels[clickedElementindex];
                            // var value = chart.value.data.datasets[clickedDatasetIndex].data[clickedElementindex];     
                            // alert("Clicked: " + label + " - " + value);
                            cardDate.value = chart.value.data.labels[clickedElementindex];
                            cardLabels.value.splice(0, cardLabels.value.length);
                            cardColors.value.splice(0, cardColors.value.length);
                            cardDataset.value.splice(0, cardDataset.value.length);
                            // empty the the three arrays
                            triggerRef(cardLabels);
                            triggerRef(cardColors);
                            triggerRef(cardDataset);
                            cardColors.value = cardColors.value.splice(0, cardColors.value.length);
                            chart.value.data.datasets.forEach((dataset) => {
                                cardLabels.value.push(dataset.label);
                                cardDataset.value.push(dataset.data[clickedElementindex]);
                                cardColors.value.push(dataset.backgroundColor)
                            })
                            triggerRef(cardLabels);
                            triggerRef(cardColors);
                            triggerRef(cardDataset);
                            cardModel.value = true
                        }
                    }
                }
            }
            // add datasets to charData
            for(let index in datasets) {
                let entry = {
                    label: labels[index],
                    data: [],
                    fill:false,
                    borderColor: colors[index],
                    backgroundColor: colors[index],
                    pointRadius: 2,
                    borderWidth: 1
                }
                // Extract the values from the [date, value] pairs
                let values = [];
                datasets[index].forEach((value) => {
                    values.push(value[1]);
                });
                entry.data = values;
                chartData.data.datasets.push(entry);    // Assign the entry to chartData
            }
            
            const ctx = document.getElementById('generation-chart');
            if(!chart.value) {
                console.debug("ChartSourceSplit -> updateChartData() -> New Chart");
                Chart.register(...registerables);
                chart.value = new Chart(ctx, chartData);
                triggerRef(chart);
            }
            else {
                console.debug("ChartSourceSplit -> updateChartData() -> Chart Update");
                // Remove data
                chart.value.data.labels.splice(0, chart.value.data.labels.length); // empty the labels list
                chart.value.data.datasets.splice(0, chart.value.data.datasets.length); // empty the datasets list
                chart.value.update();
                triggerRef(chart);
                // Add new data
                chart.value.data.labels.push(...chartData.data.labels); // set new labels
                chartData.data.datasets.forEach((dataset) => {  // build the datasets
                    chart.value.data.datasets.push(dataset);
                });
                chart.value.options.plugins.title.text = chartData.options.plugins.title.text; // set the new title
                chart.value.update();
                triggerRef(chart);
                // chart.value.update(chartData);
                // triggerRef(chart);
            }
        }

        /**
         * Called to retrieve new data from the API of REE
         */
        function updateList(_fechainicio) {
            console.debug(`ChartSourceSplit -> updateList() -> _fechainicio: ${_fechainicio}`);
            let dates = resolveDates(_fechainicio);
            console.debug(`ChartSourceSplit -> updateList() -> initdate: ${dates[0]} , enddate: ${dates[1]}`);
            store.reeApi.getSplit(dates[0], dates[1])
            .then( (response) => {
                if(typeof(response) == 'number') { // an error ocurred
                    console.error(`ChartSourceSplit -> updateList() -> reeApi.getHourlyPrices returned ${response}`);
                    $q.notify({
                        color: 'negative',
                        textColor: 'white',
                        icon: 'error',
                        message: `Desglose de generaci칩n no disponible.`,
                        timeout: 5000,
                        position: "center"
                        })
                    return;     // nothing to do
                }
                console.debug("ChartSourceSplit -> updateList() -> New data retrieved");
                let labels = [];    // e.g. "Hidr치ulica", "Turbinaci칩n bombeo" or "Nuclear"
                let colors = [];
                let datasets = [];  // one per label
                if(response.length > 0) {
                    response.forEach((source) => {
                        let dataset = [];
                        labels.push(source.attributes.title);
                        colors.push(source.attributes.color);
                        source.attributes.values.forEach((value) => {
                            let datetime = value.datetime.split("T");
                            let date = datetime[0].split("-");
                            let datestr = `${date[2]}-${date[1]}`;
                            dataset.push([datestr, value.value]);
                        });
                        // Each dataset inside datasets is a list of [date, value] tuples
                        datasets.push(dataset); 
                    });
                    updateChartData(labels, colors, datasets);
                }
            })
            .catch(error => {
                console.debug(error);
            })
        }

        // HOOKS
        onMounted(() => {
            canvasSize.value = utils.setCanvasSize(0.7, 0.4);
            if(!fecha.value) {
                const currentDate = new Date();
                let cDay = currentDate.getDate();
                let cMonth = currentDate.getMonth() + 1;
                let cYear = currentDate.getFullYear();
                let cHour = currentDate.getHours();
                fecha.value = `${cDay}-${cMonth}-${cYear}`;
                hora.value = `${cHour}:00`;
                rango.value = 24;
            }
            updateList(fecha.value);
        });

        return {
            fecha,
            hora,
            rango,
            chart,
            canvasSize,
            cardDate,
            cardLabels,
            cardDataset,
            cardColors,
            cardModel
        }
    }
})
</script>